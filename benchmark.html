<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Winnow Benchmark</title>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
  <style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  html { font-size: 16px; font-family: Georgia; }
  body { padding: 1rem; }
  section { display: flex; flex-flow: row wrap; margin-bottom: 2rem; }
  h1, h2, h3 { margin-bottom: 1rem; width: 100%; }
  hr { margin-bottom: 1rem; margin-top: 1rem; }

  /* compiler tests */
  pre { background: #eee; font-family: "Source Code Pro", monospace; padding: 0.5rem; }
  pre.winnow { width: 55%; }
  pre.felt { margin-left: 1rem; width: calc(45% - 1rem); }

  /* sifting tests */
  .siftingTest .eventTable, .siftingTest .partialMatches { font-family: "Source Code Pro", monospace; }
  .eventTable { width: 22%; margin-right: 3%; }
  .eventTable tbody td { white-space: pre; }
  .eventTable tr.selected { background: lemonchiffon; }
  .partialMatches { display: flex; flex-flow: row wrap; width: 75%; }
  .partialMatch { margin-bottom: 1rem; margin-right: 1rem; width: 200px; }
  .partialMatch .header { background: #555; color: white; font-weight: bold; }
  .partialMatch.complete .header { background: darkgreen; }
  .partialMatch.accept .header { background: darkblue; }
  .partialMatch.die .header { background: darkred; }
  .partialMatch .row { padding: 0.5rem; }
  .partialMatch .row:not(.header):nth-child(odd) { background: #eee; }
  .partialMatch .row:nth-child(even) { background: #ddd; }
  </style>
</head>
<body>
  <main>
    <h1>Winnow Benchmark</h1>
    <p>Open the browser console to view timings.</p>
  </main>
  <script src="datascript-0.18.4.min.js"></script>
  <script src="util.js"></script>
  <script src="parser.js"></script>
  <script src="compiler.js"></script>
  <script src="runner.js"></script>
  <script>
  const schema = {
    // character traits
    curse:  {":db/cardinality": ":db.cardinality/many"},
    value:  {":db/cardinality": ":db.cardinality/many"},
    // other stuff
    actor:  {":db/valueType": ":db.type/ref"},
    cause:  {":db/valueType": ":db.type/ref"},
    source: {":db/valueType": ":db.type/ref"},
    target: {":db/valueType": ":db.type/ref"},
    projectContributor: {":db/valueType": ":db.type/ref", ":db/cardinality": ":db.cardinality/many"},
    tag:    {":db/cardinality": ":db.cardinality/many"},
  };

  const allEventSpecs = [
    //{eventType: 'enterTown'},
    //{eventType: 'leaveTown'},
    //{eventType: 'showHospitality'},
    {eventType: 'getCoffeeWith', tags: ['friendly']},
    {eventType: 'physicallyAttack', tags: ['unfriendly', 'harm', 'major']},
    {eventType: 'disparagePublicly', tags: ['unfriendly', 'harm']},
    {eventType: 'sendPostcard', tags: ['friendly']},
    {eventType: 'insult', tags: ['unfriendly']},
    {eventType: 'insultDismissively', tags: ['unfriendly', 'highStatus']},
    {eventType: 'rejectSuperiority', tags: ['unfriendly', 'lowStatus']},
    {eventType: 'flirtWith_accepted', tags: ['romantic', 'positive']},
    {eventType: 'flirtWith_rejected', tags: ['romantic', 'negative', 'awkward']},
    {eventType: 'askOut_accepted', tags: ['romantic', 'positive', 'major']},
    {eventType: 'askOut_rejected', tags: ['romantic', 'negative', 'awkward', 'major']},
    {eventType: 'propose_accepted', tags: ['romantic', 'positive', 'major']},
    {eventType: 'propose_rejected', tags: ['romantic', 'negative', 'awkward', 'major']},
    {eventType: 'breakUp', tags: ['romantic', 'negative', 'major']},
    {eventType: 'buyLunchFor', tags: ['friendly']},
    {eventType: 'inviteIntoGroup', tags: ['highStatus', 'friendly', 'helps']},
    {eventType: 'shunFromGroup', tags: ['highStatus', 'unfriendly', 'harm']},
    {eventType: 'apologizeTo', tags: ['friendly']},
    {eventType: 'begForFavor', tags: ['lowStatus']},
    {eventType: 'extortFavor', tags: ['highStatus']},
    {eventType: 'callInFavor', tags: ['highStatus']},
    {eventType: 'callInExtortionateFavor', tags: ['highStatus', 'harm']},
    {eventType: 'playTheFool', tags: ['lowStatus', 'friendly']},
    {eventType: 'playRoyalty', tags: ['highStatus', 'friendly']},
    {eventType: 'neg', tags: ['highStatus', 'romantic', 'negative']},
    {eventType: 'askForHelp', tags: ['lowStatus', 'friendly']},
    {eventType: 'deferToExpertise', tags: ['career', 'lowStatus']},
    //{eventType: 'noticeMeSenpai', tags: ['lowStatus', 'romantic']},
    {eventType: 'deliberatelySabotage', tags: ['career', 'unfriendly', 'harm', 'major']},
    {eventType: 'collab:phoneItIn', tags: ['career', 'harm']},
    {eventType: 'collab:goAboveAndBeyond', tags: ['career', 'helps']},
  ];

  // Add an event to the DB and return an updated DB.
  function addEvent(db, event) {
    const transaction = [[":db/add", -1, "type", "event"]];
    for (const attr of Object.keys(event)) {
      if (attr === "tags") continue;
      transaction.push([":db/add", -1, attr, event[attr]]);
    }
    for (const tag of event.tags || []) {
      transaction.push([":db/add", -1, "tag", tag]);
    }
    return datascript.db_with(db, transaction);
  }

  // compile pattern
  const violationOfHospitality = `
(pattern violationOfHospitality
  (event ?e1 where
    eventType: enterTown,
    actor: ?guest)
  (event ?e2 where
    eventType: showHospitality,
    actor: ?host,
    target: ?guest,
    ?host.value: communalism) ; not strictly needed?
  (event ?e3 where
    tag: harm,
    actor: ?host,
    target: ?guest)
  ;; make sure the guest hasn't left town
  (unless-event ?eMid between ?e1 ?e3 where
    eventType: leaveTown,
    actor: ?guest))
`;
  const parsed = parse(violationOfHospitality);
  const compiled = compile(parsed);
  const pattern = compiled[0];

  // set up partial match pool
  let partialMatches = [];
  for (let i = 0; i < 500; i++) {
    partialMatches.push({pattern: pattern, bindings: {}});
  }
  console.log(partialMatches);

  // make DB
  let db = datascript.empty_db(schema);

  // generate and add characters
  const charsToCreate = 5;
  const testCharNames = ["Mira", "Emin", "Sarah", "Vincent", "Zach"];
  const allCharacterIDs = [];
  for (let i = 0; i < charsToCreate; i++) {
    const transaction = [
      [":db/add", -1, "type", "char"],
      [":db/add", -1, "charName", testCharNames[i]],
      [":db/add", -1, "value", "communalism"], // everyone values communalism for testing lol
    ];
    db = datascript.db_with(db, transaction);
    allCharacterIDs.push(i+1);
  }

  // push a bunch of random events and benchmark performance
  const events = [];
  const timings = [];
  const rules = "[]";
  const firstEventID = charsToCreate + 1;
  for (let i = firstEventID; i < firstEventID + 100; i++) {
    // On the first iteration, immediately push an enterTown event.
    // This doubles the match pool size and ensures that half the matches
    // in the pool are initialized, to imitate a more "realistic" pool
    // (with a mix of uninitialized and initialized matches)
    // while keeping the overall pool size fixed.
    const event = (i === firstEventID)
      ? {eventType: "enterTown"}
      : clone(randNth(allEventSpecs));
    event.actor = randNth(allCharacterIDs);
    event.target = randNth(allCharacterIDs.filter(id => id !== event.actor));
    events.push(event);
    db = addEvent(db, event);

    // benchmark
    const startTime = performance.now();
    partialMatches = mapcat(partialMatches, pm => tryAdvance(pm, db, rules, i));
    partialMatches = partialMatches.filter(pm => pm.lastStep !== "die" && pm.lastStep !== "complete");
    const endTime = performance.now();
    console.log(partialMatches.length, endTime - startTime);
    timings.push(endTime - startTime);
  }

  console.log(timings);
  console.log("avg", timings.reduce((a, b) => a + b) / timings.length);
  console.log("min", Math.min(...timings));
  console.log("max", Math.max(...timings));
  </script>
</body>
</html>
